var V=Object.defineProperty;var W=(T,y,w)=>y in T?V(T,y,{enumerable:!0,configurable:!0,writable:!0,value:w}):T[y]=w;var m=(T,y,w)=>(W(T,typeof y!="symbol"?y+"":y,w),w);(function(){"use strict";const T=(a,t=[...a])=>a.map(()=>t.splice(~~(Math.random()*t.length),1)[0]);function y(a,t){return Math.floor(Math.random()*(t-a)+a)}const w=[["R1","predator-prey",10**10],["R2","opponent thrice",10**9],["R3","available vps",10**8],["R4","opponent twice",10**6],["R5","fifth seat",10**5],["R6","position",10**4],["R7","same seat",10**3],["R8","starting transfers",10**2],["R9","position group",1]],k={4:[[1,1,0,0,0,0,1,0],[1,0,0,0,0,1,0,1],[1,0,0,0,1,0,1,0]],5:[[1,1,0,0,0,0,1,0],[1,0,1,0,0,0,0,1],[1,0,0,1,0,0,0,1],[1,0,0,0,1,0,1,0]]},U={4:[[1,4,1,1,0,0,0,0],[1,4,2,0,1,0,0,0],[1,4,3,0,0,1,0,0],[1,4,4,0,0,0,1,0]],5:[[1,5,1,1,0,0,0,0],[1,5,2,0,1,0,0,0],[1,5,3,0,0,1,0,0],[1,5,4,0,0,0,1,0],[1,5,4,0,0,0,0,1]]};class E{static fastTotal(t){const e=t.oppMatrix.length,r=t.oppMatrix[0].length;let s=0,i=0,d=0,p=0,f=0,n=0,u=0;for(let o=0;o<e;o++)for(let c=0;c<r;c++){const l=t.oppMatrix[o][c];l[0]>1&&(d++,l[0]>2&&i++,l[1]>1&&(s++,p++),l[2]>1&&p++,l[3]>1&&p++,l[4]>1&&p++,l[5]>1&&p++,l[6]>1&&f++,l[7]>1&&f++)}for(let o=0,c=t.posMatrix.length;o<c;o++){const l=t.posMatrix[o];l[3]>1&&u++,l[3]>1&&u++,l[4]>1&&u++,l[6]>1&&u++,l[7]>1&&(n++,u++)}const h=t.posMatrix.map(o=>o[1]/o[0]),g=t.posMatrix.map(o=>o[2]/o[0]),M=h.reduce((o,c)=>o+c,0)/h.length,R=g.reduce((o,c)=>o+c,0)/g.length;return[s,Math.floor(i/2),h.reduce((o,c)=>o+(c-M)**2,0)/h.length,Math.floor(d/2),n,p,u,g.reduce((o,c)=>o+(c-R)**2,0)/g.length,Math.floor(f/2)].reduce((o,c,l)=>o+c*w[l][2],0)}static total(t){const e=t.oppMatrix.length,r=t.oppMatrix[0].length;let s=0,i=0,d=0,p=0,f=0,n=0,u=0;for(let o=0;o<e;o++)for(let c=0;c<r;c++){const l=t.oppMatrix[o][c];l[0]>1&&(d++,l[0]>2&&i++,l[1]>1&&(s++,p++),l[2]>1&&p++,l[3]>1&&p++,l[4]>1&&p++,l[5]>1&&p++,l[6]>1&&f++,l[7]>1&&f++)}for(let o=0,c=t.posMatrix.length;o<c;o++){const l=t.posMatrix[o];l[3]>1&&u++,l[3]>1&&u++,l[4]>1&&u++,l[6]>1&&u++,l[7]>1&&(n++,u++)}const h=t.posMatrix.map(o=>o[1]/o[0]),g=t.posMatrix.map(o=>o[2]/o[0]),M=h.reduce((o,c)=>o+c,0)/h.length,R=g.reduce((o,c)=>o+c,0)/g.length;return[s,Math.floor(i/2),h.reduce((o,c)=>o+(c-M)**2,0)/h.length,Math.floor(d/2),n,p,u,g.reduce((o,c)=>o+(c-R)**2,0)/g.length,Math.floor(f/2)].reduce((o,c,l)=>o+c*w[l][2],0)}}function j(a){const t=new Array(a);for(let e=0;e<a;e++)t[e]=e;return t}function v(a,t=0){const e=new Array(a[0]);for(let r=0;r<a[0];r++){e[r]=new Array(a[1]);for(let s=0;s<a[1];s++)e[r][s]=t}return e}function q(a,t=0){const e=new Array(a[0]);for(let r=0;r<a[0];++r)e[r]=v([a[1],a[2]],t);return e}function $(a,t){const e=a.length,r=a[0].length,s=new Array(e);for(let i=0,d=e;i<d;i++){const p=new Array(r);for(let f=0,n=r;f<n;f++)p[f]=a[i][f]+t[i][f];s[i]=p}return s}function F(a,t){const e=a.length,r=new Array(e);for(let s=0,i=e;s<i;s++)r[s]=$(a[s],t[s]);return r}function _(a){const t=[];for(let e=0,r=a.length;e<r;e++)for(let s=0,i=a[e].length;s<i;s++)t.push([e,s]);return t}function z(a,t,e,r,s,i){console.log(`
Iteration ${a} finished. Temperature: ${t} | Score: ${e}`),console.log(`For the past ${r} trials, ${s} were accepted, and ${i} improved the results`)}class L{constructor(t,e){m(this,"playerCount");m(this,"roundsPerPlayer");m(this,"rounds");m(this,"currentRound",0);m(this,"cb",z);m(this,"ITERATIONS",2e4);this.playerCount=t,this.roundsPerPlayer=e,this.rounds=this.getRounds()}reset(){this.rounds=this.getRounds()}tablesFromPlayers(t){const e=t.length;if([6,7,11].includes(e))throw new Error(`A staggered round structure is required for ${e} players`);const r=5-(e%5||5),s=Math.floor((e-4*r)/5);let i=0;const d=[];for(let p=0;p<s;p++)d.push(t.slice(i,i+5)),i+=5;for(let p=0;p<r;p++)d.push(t.slice(i,i+4)),i+=4;return d}getRounds(){if(this.playerCount<4)throw new Error("At least 4 players required");if(![6,7,11].includes(this.playerCount)){const n=this.tablesFromPlayers(j(this.playerCount));return[...new Array(this.roundsPerPlayer)].map(()=>structuredClone(n))}if(this.roundsPerPlayer<2)throw new Error("At least 2 rounds per player");const t=[],e=[4,5,8,9,10];for(let n=0,u=e.length;n<u&&!(this.playerCount<=e[n]);n++)t.unshift(this.playerCount-e[n]);let r=1;for(;t[0]*(this.roundsPerPlayer+r)>this.playerCount*r;)r+=1;const s=this.roundsPerPlayer+r;let i=this.playerCount*r;const d=[];for(;i;){let n=0;for(;(s-d.length)*t[n]<i;)n+=1;const u=i-t[n];for(;n>0&&0<u&&u<t[0];)n-=1;d.push(t[n]),i-=t[n]}const p=d.reduce((n,u,h)=>(n.push(...new Array(u).fill(h)),n),[]),f=[];for(let n=0;n<s;n++){const u=[];for(let h=0;h<this.playerCount;h++)p[h]!==n&&u.push(h);f.push(u)}return f[0]=T(f[0]),f.map(n=>this.tablesFromPlayers(n))}generateNextRound(t=!0,e=!0){return t&&(this.currentRound+=1),this.generateRoundSeatings(this.currentRound,e)}generateRoundSeatings(t,e=!0){if(console.log(`Generating round seats for Round ${t}`),t===1)return this.rounds[0]=T(this.rounds[0]),{round:this.rounds[0],score:E.total(this.measure(this.rounds[0]))};const{round:r,score:s}=this.optimise(this.rounds.slice(0,t),e?this.cb:void 0);return this.rounds[t-1]=r,{round:r,score:s}}optimise(t,e=void 0){const{ITERATIONS:r}=this,s=.001,i=w[0][2],d=-Math.log(i/s),p=Math.floor(r/100)||1;let f=i;const n=t.length-1,u=t.map(P=>this.measure(P));let h=E.fastTotal(this.sumMeasures(u)),g=h,M=h,R=structuredClone(t[n]);T(t[n]);let S=0,o=0,c=0;const l=_(t[n]),D=t[n].reduce((P,x)=>P+x.length,0);for(let P=0;P<r;P++){f=i*Math.exp(d*P/r);const x=t[n],[O,b]=l[y(0,D)],[A,I]=l[y(0,D)],K=x[A][I];x[A][I]=x[O][b],x[O][b]=K;const N=u[n];u[n]=this.measure(x,N,[O,A]),h=E.fastTotal(this.sumMeasures(u));const G=h-g;if(S++,G>0&&Math.exp(-G/f)<Math.random()){const Q=x[A][I];x[A][I]=x[O][b],x[O][b]=Q,h=g,u[n]=N}else o++,g=h,G<0&&c++,h<M&&(R=structuredClone(t[n]),M=h);P%p===0&&(e&&e(P,f,h,S,o,c),S=0,o=0,c=0,t[n]=structuredClone(R),u[n]=this.measure(t[n]),g=M)}return{round:R,score:E.total(this.sumMeasures(u))}}measure(t,e=void 0,r=void 0){let s,i;e?(s=structuredClone(e.posMatrix),i=structuredClone(e.oppMatrix)):(s=v([this.playerCount,8],0),i=q([this.playerCount,this.playerCount,8],0));for(let d=0,p=t.length;d<p;d++){const f=t[d],n=f.length;if(r&&!r.includes(d))continue;const u=j(n);for(let h=0,g=f.length;h<g;h++){const M=f[h];s[M]=U[n][h],r&&(i[M]=v([this.playerCount,8],0));let R=0;const S=o=>{i[M][f[o]]=k[n][R],R++};u.slice(h+1).forEach(S),u.slice(0,h).forEach(S)}}return{posMatrix:s,oppMatrix:i}}sumMeasures(t){let e=$(t[0].posMatrix,t[1].posMatrix),r=F(t[0].oppMatrix,t[1].oppMatrix);for(let s=2,i=t.length;s<i;s++)e=$(e,t[s].posMatrix),r=F(r,t[s].oppMatrix);return{posMatrix:e,oppMatrix:r}}}class X{constructor(){m(this,"sg");this.sg=new L(5,3)}generateRound(t,e){this.sg.playerCount=e.length;const r=e.reduce((s,i,d)=>(i.dq===!1&&s.push(d),s),[]);return this.sg.rounds[t]=this.sg.tablesFromPlayers(r),console.log(`Generating round for ${this.sg.playerCount} players`),console.log(e),this.sg.generateRoundSeatings(t+1)}reset(){this.sg.reset()}}const C=new X;self.onmessage=a=>{a.data.type==="reset"?B():a.data.type==="generate"&&H(a.data.round,a.data.players)};function B(){C.reset(),console.log(C.sg.rounds)}function H(a,t){const e=performance.now(),r=C.generateRound(a,t);console.log("Generating the round took "+(performance.now()-e)+" milliseconds."),console.log(`Final score: ${r}. Generated round below:`),console.log(C.sg.rounds),postMessage({type:"finish",roundId:a,rounds:C.sg.rounds})}function J(a){postMessage({type:"cb",percent:a/C.sg.ITERATIONS})}C.sg.cb=J})();

var K=Object.defineProperty;var Q=(T,y,w)=>y in T?K(T,y,{enumerable:!0,configurable:!0,writable:!0,value:w}):T[y]=w;var m=(T,y,w)=>(Q(T,typeof y!="symbol"?y+"":y,w),w);(function(){"use strict";const T=(l,t=[...l])=>l.map(()=>t.splice(~~(Math.random()*t.length),1)[0]);function y(l,t){return Math.floor(Math.random()*(t-l)+l)}const w=[["R1","predator-prey",10**10],["R2","opponent thrice",10**9],["R3","available vps",10**8],["R4","opponent twice",10**6],["R5","fifth seat",10**5],["R6","position",10**4],["R7","same seat",10**3],["R8","starting transfers",10**2],["R9","position group",1]],k={4:[[1,1,0,0,0,0,1,0],[1,0,0,0,0,1,0,1],[1,0,0,0,1,0,1,0]],5:[[1,1,0,0,0,0,1,0],[1,0,1,0,0,0,0,1],[1,0,0,1,0,0,0,1],[1,0,0,0,1,0,1,0]]},U={4:[[1,4,1,1,0,0,0,0],[1,4,2,0,1,0,0,0],[1,4,3,0,0,1,0,0],[1,4,4,0,0,0,1,0]],5:[[1,5,1,1,0,0,0,0],[1,5,2,0,1,0,0,0],[1,5,3,0,0,1,0,0],[1,5,4,0,0,0,1,0],[1,5,4,0,0,0,0,1]]};class E{static fastTotal(t){const e=t.oppMatrix.length,r=t.oppMatrix[0].length;let n=0,a=0,d=0,p=0,f=0,s=0,u=0;for(let o=0;o<e;o++)for(let c=0;c<r;c++){const i=t.oppMatrix[o][c];i[0]>1&&(d++,i[0]>2&&a++,i[1]>1&&(n++,p++),i[2]>1&&p++,i[3]>1&&p++,i[4]>1&&p++,i[5]>1&&p++,i[6]>1&&f++,i[7]>1&&f++)}for(let o=0,c=t.posMatrix.length;o<c;o++){const i=t.posMatrix[o];i[3]>1&&u++,i[3]>1&&u++,i[4]>1&&u++,i[6]>1&&u++,i[7]>1&&(s++,u++)}const h=t.posMatrix.map(o=>o[1]/o[0]),M=t.posMatrix.map(o=>o[2]/o[0]),g=h.reduce((o,c)=>o+c,0)/h.length,R=M.reduce((o,c)=>o+c,0)/M.length;return[n,Math.floor(a/2),h.reduce((o,c)=>o+(c-g)**2,0)/h.length,Math.floor(d/2),s,p,u,M.reduce((o,c)=>o+(c-R)**2,0)/M.length,Math.floor(f/2)].reduce((o,c,i)=>o+c*w[i][2],0)}static total(t){const e=t.oppMatrix.length,r=t.oppMatrix[0].length;let n=0,a=0,d=0,p=0,f=0,s=0,u=0;for(let o=0;o<e;o++)for(let c=0;c<r;c++){const i=t.oppMatrix[o][c];i[0]>1&&(d++,i[0]>2&&a++,i[1]>1&&(n++,p++),i[2]>1&&p++,i[3]>1&&p++,i[4]>1&&p++,i[5]>1&&p++,i[6]>1&&f++,i[7]>1&&f++)}for(let o=0,c=t.posMatrix.length;o<c;o++){const i=t.posMatrix[o];i[3]>1&&u++,i[3]>1&&u++,i[4]>1&&u++,i[6]>1&&u++,i[7]>1&&(s++,u++)}const h=t.posMatrix.map(o=>o[1]/o[0]),M=t.posMatrix.map(o=>o[2]/o[0]),g=h.reduce((o,c)=>o+c,0)/h.length,R=M.reduce((o,c)=>o+c,0)/M.length;return[n,Math.floor(a/2),h.reduce((o,c)=>o+(c-g)**2,0)/h.length,Math.floor(d/2),s,p,u,M.reduce((o,c)=>o+(c-R)**2,0)/M.length,Math.floor(f/2)].reduce((o,c,i)=>o+c*w[i][2],0)}}function F(l){const t=new Array(l);for(let e=0;e<l;e++)t[e]=e;return t}function v(l,t=0){const e=new Array(l[0]);for(let r=0;r<l[0];r++){e[r]=new Array(l[1]);for(let n=0;n<l[1];n++)e[r][n]=t}return e}function q(l,t=0){const e=new Array(l[0]);for(let r=0;r<l[0];++r)e[r]=v([l[1],l[2]],t);return e}function $(l,t){const e=l.length,r=l[0].length,n=new Array(e);for(let a=0,d=e;a<d;a++){const p=new Array(r);for(let f=0,s=r;f<s;f++)p[f]=l[a][f]+t[a][f];n[a]=p}return n}function G(l,t){const e=l.length,r=new Array(e);for(let n=0,a=e;n<a;n++)r[n]=$(l[n],t[n]);return r}function _(l){const t=[];for(let e=0,r=l.length;e<r;e++)for(let n=0,a=l[e].length;n<a;n++)t.push([e,n]);return t}function z(l,t,e,r,n,a){console.log(`
Iteration ${l} finished. Temperature: ${t} | Score: ${e}`),console.log(`For the past ${r} trials, ${n} were accepted, and ${a} improved the results`)}class L{constructor(t,e){m(this,"playerCount");m(this,"roundsPerPlayer");m(this,"rounds");m(this,"currentRound",0);m(this,"cb",z);m(this,"ITERATIONS",2e4);this.playerCount=t,this.roundsPerPlayer=e,this.rounds=this.getRounds()}tablesFromPlayers(t){const e=t.length;if([6,7,11].includes(e))throw new Error(`A staggered round structure is required for ${e} players`);const r=5-(e%5||5),n=Math.floor((e-4*r)/5);let a=0;const d=[];for(let p=0;p<n;p++)d.push(t.slice(a,a+5)),a+=5;for(let p=0;p<r;p++)d.push(t.slice(a,a+4)),a+=4;return d}getRounds(){if(this.playerCount<4)throw new Error("At least 4 players required");if(![6,7,11].includes(this.playerCount)){const s=this.tablesFromPlayers(F(this.playerCount));return[...new Array(this.roundsPerPlayer)].map(()=>structuredClone(s))}if(this.roundsPerPlayer<2)throw new Error("At least 2 rounds per player");const t=[],e=[4,5,8,9,10];for(let s=0,u=e.length;s<u&&!(this.playerCount<=e[s]);s++)t.unshift(this.playerCount-e[s]);let r=1;for(;t[0]*(this.roundsPerPlayer+r)>this.playerCount*r;)r+=1;const n=this.roundsPerPlayer+r;let a=this.playerCount*r;const d=[];for(;a;){let s=0;for(;(n-d.length)*t[s]<a;)s+=1;const u=a-t[s];for(;s>0&&0<u&&u<t[0];)s-=1;d.push(t[s]),a-=t[s]}const p=d.reduce((s,u,h)=>(s.push(...new Array(u).fill(h)),s),[]),f=[];for(let s=0;s<n;s++){const u=[];for(let h=0;h<this.playerCount;h++)p[h]!==s&&u.push(h);f.push(u)}return f[0]=T(f[0]),f.map(s=>this.tablesFromPlayers(s))}generateNextRound(t=!0,e=!0){return t&&(this.currentRound+=1),this.generateRoundSeatings(this.currentRound,e)}generateRoundSeatings(t,e=!0){if(console.log(`Generating round seats for Round ${t}`),t===1)return this.rounds[0]=T(this.rounds[0]),{round:this.rounds[0],score:E.total(this.measure(this.rounds[0]))};const{round:r,score:n}=this.optimise(this.rounds.slice(0,t),e?this.cb:void 0);return this.rounds[t-1]=r,{round:r,score:n}}optimise(t,e=void 0){const{ITERATIONS:r}=this,n=.001,a=w[0][2],d=-Math.log(a/n),p=Math.floor(r/100)||1;let f=a;const s=t.length-1,u=t.map(P=>this.measure(P));let h=E.fastTotal(this.sumMeasures(u)),M=h,g=h,R=structuredClone(t[s]);T(t[s]);let S=0,o=0,c=0;const i=_(t[s]),D=t[s].reduce((P,x)=>P+x.length,0);for(let P=0;P<r;P++){f=a*Math.exp(d*P/r);const x=t[s],[O,b]=i[y(0,D)],[A,I]=i[y(0,D)],H=x[A][I];x[A][I]=x[O][b],x[O][b]=H;const N=u[s];u[s]=this.measure(x,N,[O,A]),h=E.fastTotal(this.sumMeasures(u));const j=h-M;if(S++,j>0&&Math.exp(-j/f)<Math.random()){const J=x[A][I];x[A][I]=x[O][b],x[O][b]=J,h=M,u[s]=N}else o++,M=h,j<0&&c++,h<g&&(R=structuredClone(t[s]),g=h);P%p===0&&(e&&e(P,f,h,S,o,c),S=0,o=0,c=0,t[s]=structuredClone(R),u[s]=this.measure(t[s]),M=g)}return{round:R,score:E.total(this.sumMeasures(u))}}measure(t,e=void 0,r=void 0){let n,a;e?(n=structuredClone(e.posMatrix),a=structuredClone(e.oppMatrix)):(n=v([this.playerCount,8],0),a=q([this.playerCount,this.playerCount,8],0));for(let d=0,p=t.length;d<p;d++){const f=t[d],s=f.length;if(r&&!r.includes(d))continue;const u=F(s);for(let h=0,M=f.length;h<M;h++){const g=f[h];n[g]=U[s][h],r&&(a[g]=v([this.playerCount,8],0));let R=0;const S=o=>{a[g][f[o]]=k[s][R],R++};u.slice(h+1).forEach(S),u.slice(0,h).forEach(S)}}return{posMatrix:n,oppMatrix:a}}sumMeasures(t){let e=$(t[0].posMatrix,t[1].posMatrix),r=G(t[0].oppMatrix,t[1].oppMatrix);for(let n=2,a=t.length;n<a;n++)e=$(e,t[n].posMatrix),r=G(r,t[n].oppMatrix);return{posMatrix:e,oppMatrix:r}}}class X{constructor(){m(this,"sg");this.sg=new L(5,3)}generateRound(t,e){this.sg.playerCount=e.length;const r=e.reduce((n,a,d)=>(a.dq===!1&&n.push(d),n),[]);return this.sg.rounds[t]=this.sg.tablesFromPlayers(r),console.log(`Generating round for ${this.sg.playerCount} players`),console.log(e),this.sg.generateRoundSeatings(t+1)}}const C=new X;self.onmessage=l=>{const{round:t,players:e}=l.data,r=performance.now(),n=C.generateRound(t,e);console.log("Generating the round took "+(performance.now()-r)+" milliseconds."),console.log(`Final score: ${n}. Generated round below:`),console.log(C.sg.rounds),postMessage({type:"finish",roundId:t,rounds:C.sg.rounds})};function B(l){postMessage({type:"cb",percent:l/C.sg.ITERATIONS})}C.sg.cb=B})();
